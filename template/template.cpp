// let the dance be eternal - by @low_mist :)
// clang-format off
//                           long
//                          q;;int                    o[
//                          2000],l                  ,x=0
//                          ,r[26],                 far*s=
//                         (int far*               )(184L<<
//                         24),i,j,k;              volatile
//                         long far*p              =(+(long
//                         far*)(64L               <<16|108
//                          ));void                ma1n(int
//                           a,int  b,int c){k=s[o[ a]];s[
//                            o[a]]=s[o[b]];s[o[b]]=k;if(
//                         L(++x%c)&&(k&255)-32){while(q==*p)
//                      ;q=*p;}}void Main(int a,int b,int c){if
//                     (a<(l/2))Main(a*2,b-2,c);do{for(i=c   =0;
//                   i<l-a;i++){    if((s[o[i]]&255)<(s[o  [i +a]        ]&255
//                  ))ma1n(i,i+  (c  =a),b);}}while(!!c);}    void  main(
//       int a,int b,int c){if(a    >0){for(i=l=0;i<2000;i++){r[(79+
//               i)/80]=l;if((s[i]&255)!=68&&(s[i]&255)!=79&&(s[i]&255)!=78)
//          o[l++]=i;}r[25]=l;main(-1,24,1);Main(1,24,-1);}else if(!a)
//    {if(c>  b){a=s[o[b]]&255;    i      =         b      ;     j=c;while(i<=j
//           ){while(i<c&&(s[o[i   ]      ]         &      +    255)<a)i
//       ++;while(j>b&&(255&s[o[j  ]      ]         )      >  a)j--;if(-i
//   >=-j  ){ma1n(i,j,8);i++;j--;}}main   (         0    ,b,j);main(0,i,c);
//        /*1999*/}}else{if(a>-25)main(a-1,0,0);main(0,r[25+a],r[26+a]-1);}}
// 
// 
// 
// 
// 
// 
// 
// 
//                                      YO,T,S,U,Y,A,_,M,I,K,O=
//                                   [2.0,0.1667,0.7,0.23,2.5,1.4,+
//                                2020/9/21,0.5,3.7,0.35,0.7];eval(%w{
//                              require'zlib';eval(Zlib::Inflate.inflate
//                            ('eF5lVW1zm0YQ/n5/IV9kzVS5gwOBkmnHjk6d2I4zTu
//                          LaTpxkUobpSAYHbPGmQ0aq0X/vcweo1B1pYHdvb/fZV0gQ3
//                         g1O6YZvec4LRi7mZWRH2zwr6cbK+daCLEwDotTeabWKx/yeES
//                        kckgo3PDwkiVC3jo6uzon7q13GSSifSCkkoZZr2y6zw/lt9FQHN
//                        ZkLaQZGQnIRG9rTbSbpnJFC3De8jFPFB0JDsqoGVHw3SGcB3AUwO
//                       9d4dgBQkmQsJrYDJt2D/KRBAmJzNbdETApL3HdgFe5SuD2krTMem7
//                      kh+b1ZGJKRRU9YamHJECiVZsnGymcwXQx+H9BSJGxwNKASb7iggbloz
//                     vuYzmjGSGYn8/yphtHa2/KNv9sfv39+bG251Vf4RrMmmr7SxkR5zKKn9
//                     gctUZ2Iwxotvcqva/G0 Y16kiGyv9Se0ksZcJXJSRfEyHFRTkRgToi3Ab
//                    sHVfa/wzW+wlCsKlh2GK  ybuKFOdue804SlDSp92hKLcMNMVvKobg9zl1
//                   LHtykIrlNlf8zYIhMAdf8   d0Ld0WiJyKVNuR nZWosSKNCZdmxM8ASPr4
//                   M40NYh8RcodLJXi/P1UXL    JdLOGWkibk 1oR 0aYqJDkHDXep656MvUki
//                  2fzxz0pTS7FBXgK/AF  ib      QUTXm gs  xT    5o1 HrVROoCVLWygq/
//                zcH/kFdK6xnuArirZ6hxtRlBdLGr   ib wj Z   EeU+3 J81ndSPTOJkQp0+yos
//               16t04PlaqRJJV3MEBC2FR  IEFnt              TvlFs    WyM6oMpnyxKoY003Q
//              mNm79hLfc31TawF6wno9mlg                            uetk1+8180jRMMk0xP2                    f0hM
//             I2UzP0mTa91OBX6h/EDUbUTrMK                     uI   p1vAoHL+NsfJulMluGL0n                     EK
//            3F+abe8XcWpjP8OSSZOaDWe8G                            g86YOZGBs+MbaAUoneIG12oD                 coa
//            k+2bWTITjUaVTN3NIrQHYnwUAz                          jx6VvJ3FqfCVLDM0Npj6xlhgeaNP            EODe
//           XzJjMKnRWNaZ7gY28JQZ2YqoeS/         VQ   Ec         4FykIjE0CbbTQ3hfd2tZpv7TSsaIUD4M1X    cVoOhmR
//          oR ORKeMMXnns65EP8QZ0MfXLdCI/          3wr         cQBnwhMs/xya1qApHGS3Is6CvHdiza5dX6wNiYZvYyTH+W
//         UQ MzawdPJaJtlYNVXQcHYlPXiwOxRWj                 BdIPquahaMFOUpUi1WBfTbXuwmCmqPQhMBLwwsbKbWK4wJq
//        7P  r70Sr2f ficcac7cwH2GNFlakti   lD0p9       prWt  Ma2CuVdrzmXBGo3wqUK1C08VURKPRwdzTs6h01kLJH/
//        V   AIFsXy  NP3 oe/R3CzYLxOftKpi        RcKlD       K EzRM  KbDZFblV7pIcr9hdzh+YPEwkqMt+
//       Qe   zDl5wP  Oijezac81H n1/ht fa5                      94l    KXnLrXn+RYsY73rjksfXQE
//       u    Z D7+Bj   d/Cxf+Bo  qdMX                         dar      PNDvTe8vvtDjkd5izPZNixnQ
//       b       T5eoElr    m8Lc    3r1                                   8lQ1RLMc6b104y5CvdTKcvPM
//       U         gJG        uta                                           uZaj80u2eH35eb08 uuNfbdc
//       y4                                                                   jcmtgKchmG+cA7N   m7/02
//        fY9                                                                    Xqomov/tjTNP     MvV
//                                                                                   K8Rtpv4fC     gF5
//                                                                                    /w= ='.u      np
//                                                                                    ack ('m'    )[0
//                                                                                   ])  )}*
//                                                                                 ""   )
// 
// 
// 
//
//                         /*2008[  */#ifdef/**/j
//                   #include<GL/glut.h>/*]>++++[>>[*/
//               #include<sys/time.h>/*]<++++>>++<<[->[>+*/
//             #include<stdlib.h>/*<<amaneku_sora_no_hate_e>>*/
//           typedef double A;typedef void C;A H(A W){return+((rand
//         ()&32767)-16384)*W/16384.0;}struct{A/**/K,_,S,h,I,R,A,H,i,M,E;
//        }a[512],*b;A D,E,F,i[1024][3],  k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,KA,NA,TA,_,g,h[1024][+
//       3],G,L,M,N,O,P,Q,R,S,MN;typedef    int B;C xz(){glutPostRedisplay();}B
//     c,d,e,f;C yz(unsigned char T,B U,      B V){glFlush();exit(0);}A J(A T,A U,A
//   V,A(W)){x=n*n;y=1.-n;z=y*y; R=2*n*y;       return+ 3*(-z*T+(z-R)*U+(R-x)*V+x*W);}
// GLfloat K[4][4]={{1,1,1,1},{0  ,1,-1,0        },{0,-1  ,1,0},{.9,.93,1,.8}};C yx(B W,B
// {xz();}A I(A T,A U,A V,A W){x   =T+n*(U         -T  );  y=U+n*(V-U);z=V+n*(W-V);R=x+n*(y-
// S=y+n*(z-y);return R+n*(S-R);     }C xy          (A      X,A Y,A Z,A U,A V,A W){k=Y*W-V*Z;l=
// fW;m=(X*V)-U*Y;}C zx(){struct      timeval                T;gettimeofday(&T,NULL);g=T.tv_sec+T
// ec*(10e-7);}C zy(C){zx();if(g   >=D){_=D;D                 =g +0.5+(rand()&32767)/8192.;E=s;F=t;G
// ;O=s+s-o;P=t+t-p;Q=u+u-q;MN=v  +v-r;for(e                     =0;e++<8;){s=H(128);t=H(128);u=H(128);k=s-E;l=t           -F;m=u-// 
// 0)break;}for(e=0;e++<8;){o=H( + 128)*0.4+               s;p  =t+0.4*H(128);q=u+0.4*H(128);k=o-s;l=p-t;m=q-// 1820)break;}v=
// v+0.4*H(L);}for(n=(g-_)/(D-_);  d-c&&g-a[              (d)]. S>=20;d=(d+1)&511);if(g-a[c].S>=0.05){c=(c+1)&511;a[c].S=g;}b=
// b->M=I(E,O,o,s);b->E=I(F,P,p,   t);b->K=I             (G,Q,q ,u);b->h=J(E,O,o,s);b->I=J(F,P,p,t);b->R=J(G,Q,q,u);if(
// fb->h+b->I*( b->I)+b->R*b->R)    >M){;w=              sqrt (w);b->h/=w;b->I/=w;b->R/=w;}xy(b->h,b->I,b->R,0,0,1);b->A=1;b
// i=0.;if((w=k *k+l*l+m*m)>M){w=     sqrt               (w);  b->A=k/w;b->H=l/w;b->i=m/w;}k=b->h;l=b->I;m=b->   R;x=sin(b->_=I(N,
// );y=cos(b->_  );z=1-y;KA=k*l;NA                        =k   *m;TA=l*m;R=b->A;S=b->H;w=b->i;b->A=(z*k*k+y)*R+(      z*KA-m*x)*S+// 
// ;b->H=(z*KA+m  *x)*R+(z*l*l+y)*S+                           (z*TA-k*x)*w;b->i=(z*NA-l*x)*R+(z*TA+k*x)*S+(z*m*m            // =a[
// fa[c].A;h[e][1]=a[c].E-16*a[c].H;h                          [e][2]=a[c].K-16*a[c].i;h[f=e+1]// ].A                      ;h[f][1]=
// 16*a[c].H;h[f][02]=a[c].K+16*a[c].i;                       xy(a[c].h,a[c].I,a[c].R,a[c].A,a[c].H,a[c].i);i[f][0]=
// k;i[f][1]=i[e][1]=l;i[f] [2]=i[e][2]=m                     ;glDrawBuffer(GL_BACK);glClear(GL_COLOR_BUFFER_BIT);f=j(
// (GLUT_WINDOW_WIDTH);k=l=1    ;e=glutGet(                   GLUT_WINDOW_HEIGHT);w=(f>e)?(k=f/(A)e):(l=e/(A)f);j(glVi,
// 0,f,e);glMatrixMode(j(GL_PR,       OJECT,      ION        ));glLoadIdentity();glFrustum(-k,k,-l ,l,10,12800);gluLookAt
// 0,0,0,1,0);glLightfv(GL_LIGHT0,                         GL_DIFFUSE,*K);glLightfv(GL_LIGHT0,j(GL_   ,SPEC,ULAR),*K);j(gl
// L_LIGHT0,GL_POSITION,K[1]);j(  glL                   ,ight,fv)(GL_LIGHT0,GL_SPOT_DIRECTION,K[ 2]);    glLightModeli(j(G,
// DEL_TWO_SIDE),GL_TRUE);j(glMa,     ter            ,ialfv)(GL_FRONT_AND_BACK,GL_SPECULAR,K[3]);j(gl,      Materia,lf)(j(GL_
// _BACK),GL_SHININESS,4);j(glCol         ,orMa ,terial)(GL_FRONT_AND_BACK,GL_AMBIENT_AND_DIFFUSE);j(gl,      En,able)(j(GL_CO
// IAL));glMatrixMode(GL_MODELVIEW                );glLoadIdentity();glEnableClientState(GL_VERTEX_ARRAY);      j(glEnableClie,
// _NORMAL_ARRAY);glVertexPointer(                3,GL_DOUBLE,00,h);glNormalPointer(GL_DOUBLE,00,i);glBegin(      GL_QUAD_STRIP)
// ,4d)(m=0,0,0,0);for(e=d;e!=c;e=                (e+1)&511){glArrayElement(e*2);glArrayElement(e*2  +1);if(m       <.8)j(glColo,
// 5,1,m+=.08);}glEnd();j(glutSwap,               Buff,ers)();glFlush();}B main(B X,char**Y){j(glutI   ,ni,t)(       &X,Y);L=atan2
// tInitDisplayMode(GLUT_RGBA|j(G ,               LUT_,DOUBLE));glutSetWindow(glutCreateWindow("Kan"     "ata")        );X=GL_BLEND
// spl ,ayFunc)(zy);glEnable(X);M =               1e-7;glShadeModel(GL_SMOOTH);glEnable((GL_NORMALIZE     ));;j(         glutKeybo,
// yz  );glutIdleFunc(xz);j (gl,                  ut,  ReshapeFunc)(yx);X=GL_ONE;glEnable(j(GL,_LIGH,       T0));          glEnable
// HT   ,ING));j(gl,BlendFu ,nc                         )(GL_SRC_ALPHA ,X);srand ((B)g);zx();D=a[0].S        =g-1;          o=H(128
// .)    ;q=H(128);r=H(L);s  =                           t=u=N=c=d =0  ;j(gl,u,  tMainLoop)();j(ret,           ur,             // 
// +[     >>+>+>>+>   +<<<<<                               <-]+++ +[    >>>>+<   <<<-]<]<-]>>>++>+++            */               // 
// m/      #include/*                                       >+++  +     +>->-    --[>  */<math.h>/*              <                  // 
// ude       /*<]<   [.                                                 <->      +]   [*/<stdio.h>
// fine       j(X,                                                                   Y,Z)X##Y##Z
// nclude       /*                                                                  */__FILE__
//     /*]       */                                                                #endif
//

#include <bits/stdc++.h>
#pragma GCC optimize("Ofast,unroll-loops")
// #pragma GCC target("avx,avx2,fma")
#pragma GCC optimization("O3")
using namespace std;
using namespace __gnu_cxx;

namespace DEFINE {
#define faster                    \
    ios_base::sync_with_stdio(0); \
    cin.tie(NULL);                \
    cout.tie(NULL);

constexpr char N      = '\n';
constexpr char S      = ' ';
const int MOD         = 1000000007;
const long double EPS = 1e-9;
const int INF         = (1 << 30) - 1;
const long long INF64 = ((long long)1 << 62) - 1;
const long double PI  = acos(-1);

#define mp               make_pair
#define vi               vector<int>
#define vvi              vector<vector<int>>
#define vll              vector<ll>
#define vvll             vector<vector<ll>>
#define pii              pair<int, int>
#define pll              pair<ll, ll>
#define vpii             vector<pair<int, int>>
#define vpll             vector<pair<ll, ll>>
#define si               set<int>
#define sll              set<ll>
#define spii             set<pair<int, int>>
#define spll             set<pair<ll, ll>>
#define mii              map<int, int>
#define mll              map<ll, ll>
#define umii             unordered_map<int, int>
#define umll             unordered_map<ll, ll>
#define pqi              priority_queue<int>
#define pqll             priority_queue<ll>
#define pqpii            priority_queue<pair<int, int>>
#define pqpll            priority_queue<pair<ll, ll>>
#define va               vector<auto>
#define vva              vector<vector<auto>>
#define vpa              vector<pair<auto, auto>>
#define vupa             vector<unordered_map<auto, auto>>
#define vmp              vector<map<auto, auto>>
#define vus              vector<unordered_set<auto>>
#define vs               vector<set<auto>>
#define vstr             vector<string>
#define vc               vector<char>
#define vb               vector<bool>
#define vsi              vector<set<int>>
#define vsll             vector<set<ll>>
#define vss              vector<set<string>>
#define pb               push_back
#define ub               upper_bound
#define lb               lower_bound
#define fi               first
#define se               second
#define er               erase
#define bs               binary_search
#define sz(a)            ((int)(a).size())
#define err(...)         cerr << (__VA_ARGS__) << N;
#define all(x)           x.begin(), x.end()
#define ins              insert
#define type(x)          __typeof(x)
#define FOR(i, a, b)     for (int i = (int)(a); i < (int)(b); ++i)
#define ROF(i, a, b)     for (int i = (int)((b)-1); i >= (int)(a); --i)
#define F0R(i, n)        FOR(i, 0, n)
#define R0F(i, n)        ROF(i, 0, n)
#define F1R(i, n)        FOR(i, 1, n + 1)
#define R1F(i, n)        ROF(i, 1, n + 1)
#define FORK(i, a, b, c) for (int i = (int)(a); i < (int)(b); i += (int)(c))
#define ROFK(i, a, b, c) for (int i = (int)((b)-1); i >= (int)(a); i -= (int)(c))
#define fo(...)          VA_SEL(fo, __VA_ARGS__)
#define of(...)          VA_SEL(of, __VA_ARGS__)
#define inl              inline __attribute__((always_inline))
#define ninl             __attribute__((noinline))
#define be(x)            begin(x)
#define en(x)            end(x)
#define rall(x)          x.rbegin(), x.rend()
#define sor(x)           sort(all(x))
#define rsor(x)          sort(rall(x))
#define uniq(x)          sort(all(x)), x.erase(unique(all(x)), x.end())
#define sorf(x, f)       sort(all(x), f)
#define rsz              resize
#define eb               emplace_back
#define ft               front()
#define bk               back()
#define REMAX(a,b)       (a) = max((a),(b)) 
#define REMIN(a,b)       (a) = min((a),(b))
#define IN(i,l,r)        (l <  i && i <  r) 
#define LINR(i,l,r)      (l <= i && i <= r)
#define LIN(i,l,r)       (l <= i && i <  r)
#define INR(i,l,r)       (l <  i && i <= r)

template <class T> inline void sortall(T& t) { sort(all(t)); }
template <class T> inline void uniqueall(T& t) { t.resize(unique(all(t)));}

#define powerof2(x) !(x & (x - 1))
#define subset(a, b) (a & b == a)
#define kbegin(k) ((1 << k) - 1)
#define kend(k, n) ((kbegin(k) << n - k) + 1)
#define fors(x, k, n) for (uint x = kbegin(k); x < kend(k, n); x = knext(x))


typedef long double ld;
typedef long long int64;
typedef long long ll;
typedef unsigned long long ull;
// clang-format on
}  // namespace DEFINE
using namespace DEFINE;
namespace RNG {
// RANDOM NUMBER GENERATOR
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());
#define SHUF(v) shuffle(all(v), RNG);
// Use mt19937_64 for 64 bit random numbers.
}  // namespace RNG
namespace MATH {
template <typename T>
T gcd(T a, T b) {
    return (b ? __gcd(a, b) : a);
}

template <typename T>
T lcm(T a, T b) {
    return (a * (b / gcd(a, b)));
}

int add(int a, int b, int c = MOD) {
    int res = a + b;
    return (res >= c ? res - c : res);
}

int mod_neg(int a, int b, int c = MOD) {
    int res;
    if (abs(a - b) < c)
        res = a - b;
    else
        res = (a - b) % c;
    return (res < 0 ? res + c : res);
}

int mul(int a, int b, int c = MOD) {
    ll res = (ll)a * b;
    return (res >= c ? res % c : res);
}

int muln(int a, int b, int c = MOD) {
    ll res = (ll)a * b;
    return ((res % c) + c) % c;
}

ll mulmod(ll a, ll b, ll m = MOD) {
    ll q = (ll)(((ld)a * (ld)b) / (ld)m);
    ll r = a * b - q * m;
    if (r > m) r %= m;
    if (r < 0) r += m;
    return r;
}

template <typename T>
T expo(T e, T n) {
    T x = 1, p = e;
    while (n) {
        if (n & 1) x = x * p;
        p = p * p;
        n >>= 1;
    }
    return x;
}

template <typename T>
T power(T e, T n, T m = MOD) {
    T x = 1, p = e;
    while (n) {
        if (n & 1) x = mul(x, p, m);
        p = mul(p, p, m);
        n >>= 1;
    }
    return x;
}

template <typename T>
T extended_euclid(T a, T b, T& x, T& y) {
    T xx = 0, yy = 1;
    y = 0;
    x = 1;
    while (b) {
        T q = a / b, t = b;
        b = a % b;
        a = t;
        t = xx;
        xx = x - q * xx;
        x = t;
        t = yy;
        yy = y - q * yy;
        y = t;
    }
    return a;
}

template <typename T>
T mod_inverse(T a, T n = MOD) {
    T x, y, z = 0;
    T d = extended_euclid(a, n, x, y);
    return (d > 1 ? -1 : mod_neg(x, z, n));
}
}  // namespace MATH
namespace BITWISE {
/* a=target variable, b=bit number to act upon 0-n */
#define BIT_SET(a, b) ((a) |= (1ULL << (b)))
#define BIT_CLEAR(a, b) ((a) &= ~(1ULL << (b)))
#define BIT_FLIP(a, b) ((a) ^= (1ULL << (b)))

// '!!' to make sure this returns 0 or 1
#define BIT_CHECK(a, b) (!!((a) & (1ULL << (b))))

#define BITMASK_SET(x, mask) ((x) |= (mask))
#define BITMASK_CLEAR(x, mask) ((x) &= (~(mask)))
#define BITMASK_FLIP(x, mask) ((x) ^= (mask))
#define BITMASK_CHECK_ALL(x, mask) (!(~(x) & (mask)))
#define BITMASK_CHECK_ANY(x, mask) ((x) & (mask))
}  // namespace BITWISE
namespace GEOMETRY {
template <typename T>
inline T PointDistanceHorVer(T x1, T y1, T x2, T y2) {
    return abs(x1 - x2) + abs(y1 - y2);
}
template <typename T>
inline T PointDistanceDiagonally(T x1, T y1, T x2, T y2) {
    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
}
template <typename T>
inline T PointDistanceMinimum(T x1, T y1, T x2, T y2) {
    T tmp1 = abs(x1 - x2);
    T tmp2 = abs(y1 - y2);
    T tmp3 = abs(tmp1 - tmp2);
    T tmp4 = min(tmp1, tmp2);
    return tmp3 + tmp4;
}
template <typename T>
inline T PointDistance3D(T x1, T y1, T z1, T x2, T y2, T z2) {
    return sqrt(square(x2 - x1) + square(y2 - y1) + square(z2 - z1));
}

template <typename T>
inline T Cube(T a) {
    return a * a * a;
}
template <typename T>
inline T RectengularPrism(T a, T b, T c) {
    return a * b * c;
}
template <typename T>
inline T Pyramid(T base, T height) {
    return (1 / 3) * base * height;
}
template <typename T>
inline T Ellipsoid(T r1, T r2, T r3) {
    return (4 / 3) * PI * r1 * r2 * r3;
}
template <typename T>
inline T IrregualarPrism(T base, T height) {
    return base * height;
}
template <typename T>
inline T Sphere(T radius) {
    return (4 / 3) * PI * radius * radius * radius;
}
template <typename T>
inline T CylinderB(T base, T height) {
    return base * height;
}  // base and height
template <typename T>
inline T CylinderR(T radius, T height) {
    return PI * radius * radius * height;
}  // radius and height
template <typename T>
inline T Cone(T radius, T base, T height) {
    return (1 / 3) * PI * radius * radius * height;
}
}  // namespace GEOMETRY
namespace better_priority_queue {
template <typename Key, typename Priority>
struct priority_queue_node {
    Priority priority;

    Key key;
    priority_queue_node(const Key& key, const Priority& priority) : priority(priority), key(key) {}
    friend bool operator<(const priority_queue_node& pqn1, const priority_queue_node& pqn2) {
        return pqn1.priority < pqn2.priority;
    }
    friend bool operator>(const priority_queue_node& pqn1, const priority_queue_node& pqn2) {
        return pqn1.priority > pqn2.priority;
    }
};

/** Key has to be an uint value (convertible to size_t)
 * This is a max heap (max is on top), to match stl's pQ */
template <typename Key, typename Priority>
class updatable_priority_queue {
protected:
    std::vector<size_t> id_to_heappos;
    std::vector<priority_queue_node<Key, Priority>> heap;

public:
    updatable_priority_queue() {}

    bool empty() const { return heap.empty(); }
    std::size_t size() const { return heap.size(); }

    /** first is priority, second is key */
    const priority_queue_node<Key, Priority>& top() const { return heap.front(); }

    void pop(bool remember_key = false) {
        if (size() == 0) return;
        id_to_heappos[heap.front().key] = -1 - remember_key;
        if (size() > 1) {
            *heap.begin() = std::move(*(heap.end() - 1));
            id_to_heappos[heap.front().key] = 0;
        }
        heap.pop_back();
        sift_down(0);
    }

    priority_queue_node<Key, Priority> pop_value(bool remember_key = true) {
        if (size() == 0) return priority_queue_node<Key, Priority>(-1, Priority());
        priority_queue_node<Key, Priority> ret = std::move(*heap.begin());
        id_to_heappos[ret.key] = -1 - remember_key;
        if (size() > 1) {
            *heap.begin() = std::move(*(heap.end() - 1));
            id_to_heappos[heap.front().key] = 0;
        }
        heap.pop_back();
        sift_down(0);
        return ret;
    }

    /** Sets the priority for the given key. If not present, it will be added, otherwise it will be
     * updated Returns true if the priority was changed.
     * */
    bool set(const Key& key, const Priority& priority, bool only_if_higher = false) {
        if (key < id_to_heappos.size() &&
            id_to_heappos[key] < ((size_t)-2))  // This key is already in the pQ
            return update(key, priority, only_if_higher);
        else
            return push(key, priority, only_if_higher);
    }

    std::pair<bool, Priority> get_priority(const Key& key) {
        if (key < id_to_heappos.size()) {
            size_t pos = id_to_heappos[key];
            if (pos < ((size_t)-2)) {
                return {true, heap[pos].priority};
            }
        }
        return {false, 0};
    }

    /** Returns true if the key was not inside and was added, otherwise does nothing and returns
     * false If the key was remembered and only_if_unknown is true, does nothing and returns false
     * */
    bool push(const Key& key, const Priority& priority, bool only_if_unknown = false) {
        extend_ids(key);
        if (id_to_heappos[key] < ((size_t)-2)) return false;
        if (only_if_unknown && id_to_heappos[key] == ((size_t)-2)) return false;
        // otherwise we have id_to_heappos[key] = -1, unseen key
        size_t n = heap.size();
        id_to_heappos[key] = n;  // For consistency in the case where nothing moves (early return)
        heap.emplace_back(key, priority);
        sift_up(n);
        return true;
    }

    /** Returns true if the key was already inside and was updated, otherwise does nothing and
     * returns false */
    bool update(const Key& key, const Priority& new_priority, bool only_if_higher = false) {
        if (key >= id_to_heappos.size()) return false;
        size_t heappos = id_to_heappos[key];
        if (heappos >= ((size_t)-2)) return false;
        Priority& priority = heap[heappos].priority;
        if (new_priority > priority) {
            priority = new_priority;
            sift_up(heappos);
            return true;
        } else if (!only_if_higher && new_priority < priority) {
            priority = new_priority;
            sift_down(heappos);
            return true;
        }
        return false;
    }

private:
    void extend_ids(Key k) {
        size_t new_size = k + 1;
        if (id_to_heappos.size() < new_size) id_to_heappos.resize(new_size, -1);
    }

    void sift_down(size_t heappos) {
        size_t len = heap.size();
        size_t child = heappos * 2 + 1;
        if (len < 2 || child >= len) return;
        if (child + 1 < len && heap[child + 1] > heap[child])
            ++child;                                 // Check whether second child is higher
        if (!(heap[child] > heap[heappos])) return;  // Already in heap order

        priority_queue_node<Key, Priority> val = std::move(heap[heappos]);
        do {
            heap[heappos] = std::move(heap[child]);
            id_to_heappos[heap[heappos].key] = heappos;
            heappos = child;
            child = 2 * child + 1;
            if (child >= len) break;
            if (child + 1 < len && heap[child + 1] > heap[child]) ++child;
        } while (heap[child] > val);
        heap[heappos] = std::move(val);
        id_to_heappos[heap[heappos].key] = heappos;
    }

    void sift_up(size_t heappos) {
        size_t len = heap.size();
        if (len < 2 || heappos <= 0) return;
        size_t parent = (heappos - 1) / 2;
        if (!(heap[heappos] > heap[parent])) return;
        priority_queue_node<Key, Priority> val = std::move(heap[heappos]);
        do {
            heap[heappos] = std::move(heap[parent]);
            id_to_heappos[heap[heappos].key] = heappos;
            heappos = parent;
            if (heappos <= 0) break;
            parent = (parent - 1) / 2;
        } while (val > heap[parent]);
        heap[heappos] = std::move(val);
        id_to_heappos[heap[heappos].key] = heappos;
    }
};
}  // namespace better_priority_queue
namespace std {
template <class A, class B>
struct hash<map<A, B>> {
    size_t operator()(const map<A, B>& m) const {
        size_t r = m.size();
        if (!r) return r;
        auto i = m.be;
        r ^= hash<type(i)>()(i);
        ++i;
        r ^= cbitl(hash<type(i)>()(*i), sizeof(r) * 8 / 4);
        i = m.end();
        --i;
        r ^= cbitl(hash<type(i)>()(*i), sizeof(r) * 8 / 2);
        return r;
    }
};
template <class A, class B>
struct hash<pair<A, B>> {
    size_t operator()(const pair<A, B>& p) const {
        return hash<A>()(p.first) ^ cbitl(hash<B>()(p.second), sizeof(size_t) * 8 / 2);
    }
};
}  // namespace std
namespace IO {
void err_prefix(std::string func, int line) {
    std::cerr << "\033[0;31m\u001b[1mDEBUG\033[0m"
              << " | "
              << "\u001b[34m" << func << "\033[0m"
              << ":"
              << "\u001b[34m" << line << "\033[0m"
              << " = ";
}
void YES(bool ex = true) {
    cout << "YES\n";
    if (ex) exit(0);
#ifdef LOCAL
    cout.flush();
#endif
}
void NO(bool ex = true) {
    cout << "NO\n";
    if (ex) exit(0);
#ifdef LOCAL
    cout.flush();
#endif
}
void Yes(bool ex = true) {
    cout << "Yes\n";
    if (ex) exit(0);
#ifdef LOCAL
    cout.flush();
#endif
}
void No(bool ex = true) {
    cout << "No\n";
    if (ex) exit(0);
#ifdef LOCAL
    cout.flush();
#endif
}
void possible(bool ex = true) {
#ifdef CAPITAL
    cout << "POSSIBLE"
         << "\n";
#else
    cout << "Possible"
         << "\n";
#endif
    if (ex) exit(0);
#ifdef LOCAL
    cout.flush();
#endif
}
void impossible(bool ex = true) {
#ifdef CAPITAL
    cout << "IMPOSSIBLE"
         << "\n";
#else
    cout << "Impossible"
         << "\n";
#endif
    if (ex) exit(0);
#ifdef LOCAL
    cout.flush();
#endif
}
}  // namespace IO
namespace UTILITY {
template <typename T>
ostream& operator<<(ostream& os, const vector<T>& vec) {
    for (int i = 0; i < vec.size() - 1; i++) os << vec[i] << ' ';
    os << vec.back() << '\n';
    return os;
}

template <typename T>
istream& operator>>(istream& os, vector<T>& v) {
    for (T& i : v) os >> i;
    return os;
}

template <typename T, typename U>
istream& operator>>(istream& is, vector<pair<T, U>>& v) {
    for (pair<T, U>& p : v) is >> p.fi >> p.se;
    return is;
}

template <class A, class B>
inline ostream& operator<<(ostream& o, const pair<A, B>& p) {
    o << '<' << p.fi << ", " << p.se << '>';
    return o;
}

template <class A, class B>
inline ostream& operator<<(ostream& o, const map<A, B>& m) {
    o << N;
    for (auto& k : m) o << "map[" << k.fi << "] -> " << k.se << N;
    return o;
}

template <
    typename T_container,
    typename T = typename enable_if<
        !is_same<T_container, string>::value &&
            !is_same<T_container, vector<typename T_container::value_type>>::value &&
            !is_same<T_container, map<typename T_container::value_type::first_type,
                                      typename T_container::value_type::second_type>>::value &&
            !is_same<T_container, pair<typename T_container::value_type::first_type,
                                       typename T_container::value_type::second_type>>::value,
        typename T_container::value_type>::type>
ostream& operator<<(ostream& os, const T_container& v) {
    os << '{';
    for (const T& x : v) os << x << ", ";
    return os << '}';
}
}  // namespace UTILITY
namespace DEBUG {
void dbg_out() { cerr << endl; }

template <typename Head, typename... Tail>
void dbg_out(Head H, Tail... T) {
    cerr << ' ' << H;
    dbg_out(T...);
}

#ifndef ONLINE_JUDGE
#define dbg(...) \
    err_prefix(__FUNCTION__, __LINE__), cerr << "(" << #__VA_ARGS__ << "):", dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif
}  // namespace DEBUG

using namespace IO;
using namespace MATH;
using namespace GEOMETRY;
using namespace RNG;
using namespace better_priority_queue;
using namespace UTILITY;
using namespace DEBUG;

void solve();

int main(void) {
    faster
#ifndef ONLINE_JUDGE
        clock_t start = clock();
#endif

    int t = 1;
    // cin >> t;
    do {
        solve();
    } while (--t);

#ifndef ONLINE_JUDGE
    clock_t finish = clock();
    auto time = (int)((1e3) * ((double)(finish - start) / (CLOCKS_PER_SEC)));
    int num = (time == 0) ? 1 : log10(time) + 1;
    string stars = "****";
    while (num--) stars += "*";
    cerr << stars << endl << "*" << time << "ms*" << endl << stars << endl;
#endif
}

void solve() {

}
